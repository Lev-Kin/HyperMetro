type: edu
files:
- name: test/Tests.java
  visible: false
  text: |-
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.TestedProgram;

    import java.util.Arrays;

    public class Tests extends StageTest<String> {
        // test from the previous stage with one line
        @DynamicTest(order = 1)
        CheckResult oneLineTest() {

            TestedProgram main = new TestedProgram();
            main.start("./test/baltimore.json");
            String output = main.execute("/output \"SubwayLink\"").trim();

            String[] stations = new String[]{"Owings Mills", "Old Court", "Milford Mill", "Reiserstown Plaza",
                "Rogers Avenue", "West Cold Spring", "Mondawmin", "Penn North", "Uptown", "State Center",
                "Lexington Market", "Charles Center", "Shot Tower/Market Place", "Johns Hopkins Hospital"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            return CheckResult.correct();
        }

        // test of example
        @DynamicTest(order = 2)
        CheckResult multipleLineOutputTest() {

            TestedProgram main = new TestedProgram();
            main.start("./test/lausanne.json");
            String output = main.execute("/output \"m1\"").trim();

            String[] stations = new String[]{"Renes—Gare", "Epenex", "Crochy", "Cerisaie",
                "Bassenges", "EPFL", "UNL—Sorge", "Mouline", "UNL—Chemberonne", "Bourdonnette", "Melley",
                "Provence", "Montelly", "Vigie", "Lausanne—Flon"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            output = main.execute("/output \"m2\"");

            stations = new String[]{"Croisettes", "Vennes", "Fourmi", "Sallaz", "CHUV", "Ours",
                "Riponne M.Bejart", "Bessieres", "Lausanne—Flon", "Lausanne Gare CFF", "Grancy", "Delices", "Jourdils",
                "Ouchy—Olympique"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            return CheckResult.correct();
        }

        // example test pt.2 (with addition)
        @DynamicTest(order = 3)
        CheckResult additionTest() {

            TestedProgram main = new TestedProgram();
            main.start("./test/lausanne.json");

            // added a station to the end of the line
            main.execute("/append \"m1\" \"Test station 1\"");
            String output = main.execute("/output \"m1\"");

            String[] stations = new String[]{"Renes—Gare", "Epenex", "Crochy", "Cerisaie",
                "Bassenges", "EPFL", "UNL—Sorge", "Mouline", "UNL—Chemberonne", "Bourdonnette", "Melley",
                "Provence", "Montelly", "Vigie", "Lausanne—Flon", "Test station 1"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            // added another one
            main.execute("/append \"m1\" \"Test station 2\"");
            output = main.execute("/output \"m1\"");

            stations = new String[]{"Renes—Gare", "Epenex", "Crochy", "Cerisaie",
                "Bassenges", "EPFL", "UNL—Sorge", "Mouline", "UNL—Chemberonne", "Bourdonnette", "Melley",
                "Provence", "Montelly", "Vigie", "Lausanne—Flon", "Test station 1", "Test station 2"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            // added one station to the beginning of the line
            main.execute("/add-head \"m1\" \"Head\"");
            output = main.execute("/output \"m1\"");

            stations = new String[]{"Head", "Renes—Gare", "Epenex", "Crochy", "Cerisaie",
                "Bassenges", "EPFL", "UNL—Sorge", "Mouline", "UNL—Chemberonne", "Bourdonnette", "Melley",
                "Provence", "Montelly", "Vigie", "Lausanne—Flon", "Test station 1", "Test station 2"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            return CheckResult.correct();
        }

        // not existing file check
        @DynamicTest(order = 4)
        CheckResult nonexistingFileTest() {
            TestedProgram main = new TestedProgram();
            String output = main.start("tHiS_fIlE_DoEs_nOt_ExIsT.txt");
            if (output.trim().length() == 0) {
                return CheckResult.wrong("The program did not print anything when the file was not exist. ");
            }
            if (output.toLowerCase().startsWith("depot") || output.toLowerCase().endsWith("depot")) {
                return CheckResult.wrong("It looks like the program did not print an error message when the file was not exist.");
            }
            return CheckResult.correct();
        }

        // test of a case from the example
        @DynamicTest(order = 5)
        CheckResult outputLineWithTransfer() {
            TestedProgram main = new TestedProgram();
            main.start("./test/prague.json");

            String[][] stations = new String[][]{
                {"Nemocnice Motol", null},
                {"Petriny", null},
                {"Nadrazi Veleslavin", null},
                {"Borislavka", null},
                {"Dejvicka", null},
                {"Hradcanska", null},
                {"Malostranska", null},
                {"Staromestska", null},
                {"Mustek", "Linka B"},
                {"Muzeum", "Linka C"},
                {"Namesti Miru", null},
                {"Jiriho z Podebrad", null},
                {"Flora", null},
                {"Zelivskeho", null},
                {"Strasnicka", null},
                {"Skalka", null},
                {"Depo Hostivar", null}
            };

            String output = main.execute("/output \"Linka A\"");
            checkDepots(output);

            checkOutputLength(output, stations.length + 2);
            assertWithTransfer(output, stations);

            return CheckResult.correct();
        }

        @DynamicTest(order = 6)
        CheckResult connectLinesTest() {
            TestedProgram main = new TestedProgram();
            main.start("./test/prague.json");

            String[][] stations = new String[][]{
                {"Nemocnice Motol", null},
                {"Petriny", "Linka C"},
                {"Nadrazi Veleslavin", null},
                {"Borislavka", null},
                {"Dejvicka", null},
                {"Hradcanska", null},
                {"Malostranska", null},
                {"Staromestska", null},
                {"Mustek", "Linka B"},
                {"Muzeum", "Linka C"},
                {"Namesti Miru", null},
                {"Jiriho z Podebrad", null},
                {"Flora", null},
                {"Zelivskeho", null},
                {"Strasnicka", null},
                {"Skalka", null},
                {"Depo Hostivar", null}
            };

            main.execute("/connect \"Linka C\" \"I.P.Pavlova\" \"Linka A\" \"Petriny\"");
            String output = main.execute("/output \"Linka A\"");

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertWithTransfer(output, stations);

            return CheckResult.correct();
        }

        @DynamicTest(order = 7)
        CheckResult simpleRouteTest() {
            TestedProgram main = new TestedProgram();
            main.start("./test/prague.json");

            String[] correctRoute = {"Petriny", "Nadrazi Veleslavin", "Borislavka", "Dejvicka", "Hradcanska", "Malostranska",
                "Staromestska", "Mustek", "Muzeum", "Namesti Miru", "Jiriho z Podebrad", "Flora"};

            String[] sOutput = main.execute("/route \"Linka A\" \"Petriny\" \"Linka A\" \"Flora\"").toLowerCase().split("\n");

            if (sOutput.length != correctRoute.length) {
                return CheckResult.wrong("Your program printed an incorrect number of stations in the route.\n" +
                    "Expected: " + correctRoute.length + " stations." +
                    "\nYour output: " + sOutput.length + " stations.");
            }

            for (int i = 0; i < correctRoute.length; i++) {
                if (i == 0 && !correctRoute[i].toLowerCase().equals(sOutput[i].toLowerCase())) {
                    return CheckResult.wrong("The first station in the output should be '" + correctRoute[i] + "'.");
                } else if (i != 0) {
                    if (!correctRoute[i].toLowerCase().equals(sOutput[i].toLowerCase())) {
                        return CheckResult.wrong("After '" + correctRoute[i - 1] + "' should be '" + correctRoute[i] + "'.");
                    }
                }
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 8)
        CheckResult advancedRouteTest() {

            TestedProgram main = new TestedProgram();
            main.start("./test/prague.json");

            String[] stations = {"Vysehrad", "I.P.Pavlova", "Muzeum",
                "Transition to line Linka A", "Muzeum", "Mustek",
                "Transition to line Linka B", "Mustek", "Namesti Republiky"};
            String[] sOutput = main.execute("/route \"Linka C\" \"Vysehrad\" \"Linka B\" \"Namesti Republiky\"").split("\n");

            if (sOutput.length != stations.length) {
                return CheckResult.wrong("Your program printed an incorrect number of stations in the route.\n" +
                    "Expected: " + (stations.length - 4) + " stations and 2 transitions. Output should be " + stations.length + " lines." +
                    "\nYour output: " + sOutput.length + " lines");
            }

            for (int i = 0; i < stations.length; i++) {
                if (i == 0 && !stations[i].toLowerCase().equals(sOutput[i].toLowerCase())) {
                    return CheckResult.wrong("The first station in the output should be " + stations[i]);
                } else if (i != 0) {
                    if (!stations[i].toLowerCase().equals(sOutput[i].toLowerCase())) {
                        return CheckResult.wrong("After '" + stations[i - 1] + "' should be '" + stations[i] + "'.");
                    }
                }
            }
            return CheckResult.correct();
        }

        // checks for "depot" at the start and at the end
        void checkDepots(String output) {
            output = output.trim().toLowerCase();
            if (!output.startsWith("depot")) {
                throw new WrongAnswer("Your output should start with 'depot'.");
            } else if (!output.endsWith("depot")) {
                throw new WrongAnswer("Your output should end with 'depot'.");
            }
        }

        // checks number of stations in output
        void checkOutputLength(String output, int correctLength) {
            int length = output.trim().split("\n").length;
            if (length != correctLength) {
                throw new WrongAnswer("You output contains wrong number of lines.\n" +
                    "Expected: " + correctLength + " lines\n" +
                    "Your output: " + length + " lines");
            }
        }

        // checks stations
        void assertStations(String output, String[] stations) {

            String[] sOutput = output.trim().split("\n");

            for (int i = 0; i < stations.length; i++) {
                if (!sOutput[i + 1].equals(stations[i])) {
                    throw new WrongAnswer("Can't find station '" + stations[i] + "' in the line number " + (i + 2));
                }
            }
        }

        void assertWithTransfer(String output, String[][] stations) {

            String[] sOutput = output.split("\n");

            for (int i = 0; i < stations.length; i++) {
                String currentLine = sOutput[i + 1].toLowerCase().trim();
                String currentStation = stations[i][0];
                String currentTransfer = stations[i][1];
                if (currentTransfer == null) {
                    if (!currentLine.equals(currentStation.toLowerCase())) {
                        throw new WrongAnswer("There is an error in your program's reply. Some stations were not found.");
                    }
                } else if (!currentLine.contains(currentStation.toLowerCase()) ||
                    !currentLine.contains(currentTransfer.toLowerCase())) {
                    throw new WrongAnswer("Expected transfer to '" + currentTransfer + "' from '" + currentStation + "' station.");
                }
            }
        }
    }
  learner_created: false
- name: test/prague.json
  visible: false
  learner_created: false
- name: test/lausanne.json
  visible: false
  learner_created: false
- name: test/baltimore.json
  visible: false
  learner_created: false
- name: src/metro/commands/OutputCommand.java
  visible: true
  text: |
    package metro.commands;

    import metro.hmetro.Metro;

    public record OutputCommand(String line) implements Command {

        @Override
        public void execute() {
            Metro.INSTANCE.outputLine(line);
        }
    }
  learner_created: true
- name: src/metro/utils/JsonUtils.java
  visible: true
  text: |
    package metro.utils;


    import com.google.gson.JsonElement;
    import com.google.gson.JsonObject;
    import com.google.gson.JsonParser;

    import java.io.IOException;
    import java.io.Reader;
    import java.nio.file.Files;
    import java.nio.file.Path;

    public final class JsonUtils {

        private JsonUtils() {
        }

        public static JsonObject parseFromFile(Path path) throws IOException {
            try (Reader reader = Files.newBufferedReader(path)) {
                JsonParser parser = new JsonParser();
                JsonElement json = parser.parse(reader);
                return json.getAsJsonObject();
            }
        }
    }
  learner_created: true
- name: src/metro/commands/AddHeadCommand.java
  visible: true
  text: |
    package metro.commands;

    import metro.hmetro.Metro;

    public record AddHeadCommand(String line, String station) implements Command {

        @Override
        public void execute() {
            Metro.INSTANCE.addStation(line, station);
        }
    }
  learner_created: true
- name: src/metro/commands/CommandLineParser.java
  visible: true
  text: |+
    package metro.commands;

    import metro.exeception.CommandNotFoundException;

    import java.util.regex.Matcher;
    import java.util.regex.Pattern;

    public final class CommandLineParser {
        private static final Pattern connectPattern;
        private static final Pattern appendPattern;
        private static final Pattern addHeadPattern;
        private static final Pattern removePattern;
        private static final Pattern outputPattern;
        private static final Pattern exitPattern;

        static {
            String argRegex = "[\\w.]+|\"(?=\\S)[\\s\\w.]+\"";
            String twoArgsRegex = "(?<line>" + argRegex + ")\\s+(?<station>" + argRegex + ")";
            String fourArgsRegex = twoArgsRegex + "\\s+(?<line2>" + argRegex + ")\\s+(?<station2>" + argRegex + ")";

            connectPattern = Pattern.compile("^/connect\\s+" + fourArgsRegex + "$");
            appendPattern = Pattern.compile("^/append\\s+" + twoArgsRegex + "$");
            addHeadPattern = Pattern.compile("^/add-head\\s+" + twoArgsRegex + "$");
            removePattern = Pattern.compile("^/remove\\s+" + twoArgsRegex + "$");
            outputPattern = Pattern.compile("^/output\\s+(?<line>" + argRegex + ")$");
            exitPattern = Pattern.compile("^/exit$");
        }

        private CommandLineParser() {
        }

        public static Command parse(String input) {
            Matcher connectMatcher = connectPattern.matcher(input);
            Matcher appendMatcher = appendPattern.matcher(input);
            Matcher addHeadMatcher = addHeadPattern.matcher(input);
            Matcher removeMatcher = removePattern.matcher(input);
            Matcher outputMatcher = outputPattern.matcher(input);
            Matcher exitMatcher = exitPattern.matcher(input);

            if (exitMatcher.matches()) {
                return new ExitCommand();
            }

            if (outputMatcher.matches()) {
                return new OutputCommand(outputMatcher.group("line").replace("\"", "").trim());
            }

            if (appendMatcher.matches()) {
                return new AppendCommand(
                        appendMatcher.group("line").replace("\"", "").trim(),
                        appendMatcher.group("station").replace("\"", "").trim()
                );
            }

            if (addHeadMatcher.matches()) {
                return new AddHeadCommand(
                        addHeadMatcher.group("line").replace("\"", "").trim(),
                        addHeadMatcher.group("station").replace("\"", "").trim()
                );
            }

            if (removeMatcher.matches()) {
                return new RemoveCommand(
                        removeMatcher.group("line").replace("\"", "").trim(),
                        removeMatcher.group("station").replace("\"", "").trim()
                );
            }

            if (connectMatcher.matches()) {
                return new ConnectCommand(
                        connectMatcher.group("line").replace("\"", "").trim(),
                        connectMatcher.group("station").replace("\"", "").trim(),
                        connectMatcher.group("line2").replace("\"", "").trim(),
                        connectMatcher.group("station2").replace("\"", "").trim()
                );
            }
            throw new CommandNotFoundException();
        }

    }

  learner_created: true
- name: src/metro/commands/AppendCommand.java
  visible: true
  text: |
    package metro.commands;

    import metro.hmetro.Metro;

    public record AppendCommand(String line, String station) implements Command {

        @Override
        public void execute() {
            Metro.INSTANCE.appendStation(line, station);
        }
    }
  learner_created: true
- name: src/metro/list/Node.java
  visible: true
  text: |
    package metro.list;

    public class Node<T> {
        private T data;
        private Node<T> previous;
        private Node<T> next;

        public Node(T data, Node<T> previous, Node<T> next) {
            this.data = data;
            this.previous = previous;
            this.next = next;
        }

        public boolean hasNext() {
            return next != null;
        }

        public boolean hasPrevious() {
            return previous != null;
        }

        public T getData() {
            return data;
        }

        public void setData(T data) {
            this.data = data;
        }

        public Node<T> getPrevious() {
            return previous;
        }

        public void setPrevious(Node<T> previous) {
            this.previous = previous;
        }

        public Node<T> getNext() {
            return next;
        }

        public void setNext(Node<T> next) {
            this.next = next;
        }
    }
  learner_created: true
- name: src/metro/commands/Command.java
  visible: true
  text: |
    package metro.commands;

    public interface Command {
        void execute();
    }
  learner_created: true
- name: src/metro/hmetro/Metro.java
  visible: true
  text: |
    package metro.hmetro;

    import com.google.gson.JsonObject;
    import metro.exeception.LineNotFoundException;
    import metro.exeception.StationNotFoundException;
    import metro.list.DoublyLinkedList;
    import metro.list.Node;

    import java.util.HashMap;
    import java.util.Map;

    public enum Metro {
        INSTANCE;
        private static final Station DEPOT = new Station("depot");
        private final Map<String, DoublyLinkedList<Station>> metroLines = new HashMap<>();

        Metro() {
        }

        public void init(JsonObject json) {
            json.entrySet().forEach(line -> {
                DoublyLinkedList<Station> stationsList = new DoublyLinkedList<>();
                JsonObject stations = line.getValue().getAsJsonObject();
                stations.entrySet().forEach(station -> {
                    JsonObject stationJson = station.getValue().getAsJsonObject();
                    Station s = new Station();
                    s.setName(stationJson.get("name").getAsString());
                    if (!stationJson.get("transfer").isJsonNull()) {
                        stationJson.get("transfer").getAsJsonArray()
                                .forEach(jsonElement -> {
                                    Map<String, String> transfer = new HashMap<>();
                                    JsonObject transferJson = jsonElement.getAsJsonObject();
                                    transfer.put("line", transferJson.get("line").getAsString());
                                    transfer.put("station", transferJson.get("station").getAsString());
                                    s.getTransfer().add(transfer);
                                });
                    }
                    stationsList.addLast(s);
                });
                metroLines.put(line.getKey(), stationsList);
            });
        }

        public void outputLine(String line) {
            if (metroLines.containsKey(line)) {
                DoublyLinkedList<Station> stations = metroLines.get(line);
                System.out.println(DEPOT);
                System.out.print(stations);
                System.out.println(DEPOT);
                return;
            }
            throw new LineNotFoundException(line);
        }

        public void addStation(String line, String station) {
            if (metroLines.containsKey(line)) {
                metroLines.get(line).addFirst(new Station(station));
                return;
            }
            throw new LineNotFoundException(line);
        }

        public void appendStation(String line, String station) {
            if (metroLines.containsKey(line)) {
                metroLines.get(line).addLast(new Station(station));
                return;
            }
            throw new LineNotFoundException(line);
        }

        public void removeStation(String line, String station) {
            if (metroLines.containsKey(line)) {
                DoublyLinkedList<Station> list = metroLines.get(line);
                Node<Station> tmp = list.getHead();
                while (tmp != null) {
                    if (tmp.getData().getName().equals(station)) {
                        list.remove(tmp);
                        return;
                    }
                    tmp = tmp.getNext();
                }
                return;
            }
            throw new LineNotFoundException(line);
        }

        public void connect(String line1, String station1, String line2, String station2) {
            connectStation(line1, station1, line2, station2);
            connectStation(line2, station2, line1, station1);
        }

        private void connectStation(String line1, String station1, String line2, String station2) {
            if (metroLines.containsKey(line1)) {
                DoublyLinkedList<Station> stations = metroLines.get(line1);
                Node<Station> tmp = stations.getHead();
                while (tmp != null) {
                    if (tmp.getData().getName().equals(station1)) {
                        tmp.getData().getTransfer().add(
                                Map.of(
                                        "line", line2,
                                        "station", station2
                                )
                        );
                        return;
                    }
                    tmp = tmp.getNext();
                }
                throw new StationNotFoundException(station1);
            }
            throw new LineNotFoundException(line1);
        }
    }
  learner_created: true
- name: src/metro/exeception/LineNotFoundException.java
  visible: true
  text: |
    package metro.exeception;

    public class LineNotFoundException extends RuntimeException {
        public LineNotFoundException(String name) {
            super(String.format("Line \"%s\" not found", name));
        }
    }
  learner_created: true
- name: src/metro/commands/RemoveCommand.java
  visible: true
  text: |
    package metro.commands;

    import metro.hmetro.Metro;

    public record RemoveCommand(String line, String station) implements Command {

        @Override
        public void execute() {
            Metro.INSTANCE.removeStation(line, station);
        }
    }
  learner_created: true
- name: src/metro/exeception/StationNotFoundException.java
  visible: true
  text: |
    package metro.exeception;

    public class StationNotFoundException extends RuntimeException {
        public StationNotFoundException(String name) {
            super(String.format("Station \"%s\" not found", name));
        }
    }
  learner_created: true
- name: src/metro/commands/ExitCommand.java
  visible: true
  text: |
    package metro.commands;

    public record ExitCommand() implements Command {
        @Override
        public void execute() {
        }
    }
  learner_created: true
- name: src/metro/exeception/CommandNotFoundException.java
  visible: true
  text: |
    package metro.exeception;

    public class CommandNotFoundException extends RuntimeException {
        public CommandNotFoundException() {
            super("Invalid command");
        }
    }
  learner_created: true
- name: src/metro/list/DoublyLinkedList.java
  visible: true
  text: |
    package metro.list;

    import java.util.NoSuchElementException;

    public class DoublyLinkedList<T> {
        private Node<T> head;
        private Node<T> tail;
        private int size;

        public void addFirst(T data) {
            Node<T> newNode = new Node<>(data, null, head);
            if (size == 0) {
                head = tail = newNode;
            } else {
                head.setPrevious(newNode);
                head = newNode;
            }
            size++;
        }

        public void addLast(T data) {
            Node<T> newNode = new Node<>(data, tail, null);
            if (size == 0) {
                head = tail = newNode;
            } else {
                tail.setNext(newNode);
                tail = newNode;
            }
            size++;
        }

        public void removeFirst() {
            if (size == 0) {
                throw new NoSuchElementException();
            }

            if (size == 1) {
                head = tail = null;
            } else {
                head = head.getNext();
                head.setPrevious(null);
            }
            size--;
        }

        public void removeLast() {
            if (size == 0) {
                throw new NoSuchElementException();
            }

            if (size == 1) {
                head = tail = null;
            } else {
                tail = tail.getPrevious();
                tail.setNext(null);
            }
            size--;
        }

        public void remove(Node<T> current) {
            if (current == null) {
                throw new NoSuchElementException();
            }

            if (current == head) {
                removeFirst();
                return;
            }
            if (current == tail) {
                removeLast();
                return;
            }

            current.getPrevious().setNext(current.getNext());
            current.getNext().setPrevious(current.getPrevious());
            size--;
        }

        public Node<T> getHead() {
            return head;
        }

        public Node<T> getTail() {
            return tail;
        }

        public int getSize() {
            return size;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        @Override
        public String toString() {
            Node<T> tmp = head;
            StringBuilder output = new StringBuilder();
            while (tmp != null) {
                output.append(tmp.getData()).append("\n");
                tmp = tmp.getNext();
            }
            return output.toString();
        }
    }
  learner_created: true
- name: src/metro/commands/ConnectCommand.java
  visible: true
  text: |
    package metro.commands;

    import metro.hmetro.Metro;

    public record ConnectCommand(
            String line1, String station1,
            String line2, String station2) implements Command {

        @Override
        public void execute() {
            Metro.INSTANCE.connect(line1, station1, line2, station2);
        }
    }
  learner_created: true
- name: src/metro/hmetro/Station.java
  visible: true
  text: |+
    package metro.hmetro;

    import java.util.ArrayList;
    import java.util.List;
    import java.util.Map;

    public class Station {
        private String name;
        private List<Map<String, String>> transfer = new ArrayList<>();

        public Station() {
        }

        public Station(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public List<Map<String, String>> getTransfer() {
            return transfer;
        }

        public void setTransfer(List<Map<String, String>> transfer) {
            this.transfer = transfer;
        }

        @Override
        public String toString() {
            StringBuilder output = new StringBuilder();
            output.append(name);
            transfer.forEach(t -> output.append(" - ")
                    .append(t.get("station"))
                    .append(String.format(" (%s)", t.get("line"))));
            return output.toString();
        }
    }

  learner_created: true
- name: src/metro/commands/Executor.java
  visible: true
  text: |
    package metro.commands;

    public class Executor {

        public void execute(Command command) {
            command.execute();
        }
    }
  learner_created: true
- name: src/metro/InfoReader.java
  visible: true
  learner_created: true
- name: src/metro/Station.java
  visible: true
  learner_created: true
- name: src/metro/Main.java
  visible: true
  learner_created: true
- name: src/metro/Matrix.java
  visible: true
  learner_created: true
- name: src/metro/UserInterface.java
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/10344#comment
status: Solved
feedback:
  message: Congratulations!
  time: Thu, 08 Sep 2022 08:34:05 UTC
record: -1
